
Introduction

	Project Overview

Our project focuses on developing an interactive 3D physics simulation that demonstrates real-time collision detection and response between a spherical object and a complex, procedurally generated terrain. Built as a modern web application, the project leverages the core principles of Linear Algebra in Vector Space (R³) to compute accurate physical interactions. The simulation provides real-time visual feedback, including vector visualizations, making it both a robust technical application and a powerful educational tool for understanding vector mathematics.

	Project Statement

The core challenge is to digitally simulate the physical behavior of a ball moving and colliding with a 3D surface. This requires solving several interconnected problems:
	Precise Mathematics: Accurately modeling the ball's motion, detecting the exact moment of collision with a triangulated surface, and calculating a physically plausible response using vector algebra and physics principles.
	High-Performance Rendering: Efficiently processing these mathematical calculations and rendering the 3D graphics at a high, consistent frame rate to ensure a smooth and interactive user experience.
	User Interactivity: Designing an intuitive interface that allows users to manipulate simulation parameters (like terrain shape) and receive immediate visual and numerical feedback on the underlying physics.




	Project Goals

• Develop a physically accurate collision and response detection model using vector algebra.
• Achieve high-performance rendering for a smooth, real-time interactive experience.
• Create an intuitive and professional user interface with interactive controls.
• Demonstrate core linear algebra concepts visually for educational purposes.
• Build a robust and accessible web application using modern technologies.
 
	Background Theory

2.1 Vector Spaces (R³)
	    A vector space is a collection of objects (vectors) that can be added together and multiplied by scalars. In computer graphics and physics, we often use the Euclidean vector space R³, which describes positions and directions in 3D.
	A vector is an ordered triple v=(x,y,z) representing a point, displacement, or direction.
	The space is closed under vector addition and scalar multiplication, forming the foundation of linear algebra.
	Many problems in physics and computer graphics (lighting, forces, collisions) are solved by treating objects as vectors in R³.
Program usage: Every operation (normalize, reflect, triangleNormal) depends on vector arithmetic in R³.
2.2 Length & Dot Product
Dot Product (Inner Product):

 
It measures the cosine of the angle between two vectors, indicating how much one vector points in the direction of another.
Vector Length (Norm):
 
Represents the magnitude of a vector.

Program usage:
	Used in normalize(v) to compute unit vectors.
	Appears in projection formula (dot product in numerator).
	Determines distances in plane equations.
2.3 Normalization
	    Normalization scales a vector so its length is 1 without changing its direction:
 
	Unit vectors are critical in computer graphics (normals, directions, rays).
	Removes distortions caused by magnitude.
Program usage: normalize() ensures normals are length 1, which is essential for accurate reflection and projection.
2.4 Projection
	The projection of vector v onto n is:
 
	Geometric meaning: “shadow” of v on the line/axis defined by n.
	Important for decomposing vectors into parallel and perpendicular components.
Program usage: projectOnto() isolates the component of motion/force in a given direction (collision checks, constraints, or alignment tests).
2.5 Reflection

	Reflection is based on projection:
 
	Derives from subtracting twice the normal component.
	Guarantees that the angle of incidence equals the angle of reflection.
Program usage: reflect() computes bounce directions in physics and light ray reflection in rendering.
2.6 Signed Distance from Point to Plane
	The perpendicular distance of point p to a plane through p_0 with normal n ̂

 
	d>0: point lies in direction of the normal.
	d<0: opposite side.
	d=0: point lies on the plane.
Program usage: planeSignedDistance() determines whether points are above, below, or exactly on a surface (important for collision handling).
2.7 Linear, Affine, and Convex Combinations
Linear Combination: any weighted sum of vectors.
Affine Combination: weights sum to 1 → keeps points in the same plane.
Convex Combination: all weights ≥ 0, sum = 1 → guarantees point lies inside convex hull.
Program usage:
	Centroid is an affine combination.
	Barycentric coordinates are convex combinations when all weights are positive.
2.8 Normal Vector of a Triangle
    Given vertices a, b, c, the normal is:
 
	The cross product produces a vector perpendicular to both edges.
	Magnitude = parallelogram area, half of it = triangle area.
Program usage: triangleNormal() computes surface orientation used for lighting, back-face culling, and physics.
2.9 Centroid of a Triangle
    The centroid is the balancing point of a triangle:
 
	Intersection of medians.
	Divides each median in ratio 2:1.
Program usage: triangleCentroid() provides triangle centers for visualization, mesh analysis, and simulation (center of mass).
2.10 Barycentric Coordinates
    A point p can be expressed as:
 
	If all α, β, γ>0 → the point is inside triangle.
	If one = 0 → the point is on edge.
	If one = 1 → the point is at vertex.
	If any < 0 → the point is outside triangle.
Program usage: pointInTriangle() checks point location, crucial for mesh picking, texture mapping, and interpolation of attributes (color, normals).


3.  System Flowchart and Project Results


3.1. System Flowchart

 

3.2.  Project Results and What They Mean
 
What it shows: 
	Green surface: Terrain built from many small triangles.
	Red sphere: Ball sitting on the terrain.
	Blue arrows on the surface: The surface normals of each triangle. A normal is a vector perpendicular to the triangle’s surface
What it tells:
	Terrain geometry: The slopes and hills are created by different triangle heights. Steeper slopes have tilted arrows, flat areas have arrows pointing straight up.
	Ball–terrain interaction: Ball is on surface and the program continuously checks ball’s position and highlights it. 
 
What it shows: 
	Colored arrows at the ball:
	Red arrow: incoming velocity vector (direction it was moving).
	Yellow arrow: reflected velocity vector (where the ball would go if it bounced perfectly).
	Green arrow: The surface normal at the exact point where the ball touches the terrain.

What it tells:
	Physics visualization: The system is showing how the ball’s velocity interacts with the surface.
	Role of the surface normal: The terrain’s normal at the contact point is what determines the reflection.
	Interpretation: The simulation is calculating vector projection + reflection correctly.
  
What it shows:
	Terrain - divided into grid.
	Grid point - (i, j)
	Equation of terrain type -> y = f (i, j)
Smooth: 
	return 0;
Hills: 
	const hill1 = Math.sin(i * 0.5) * Math.cos(j * 0.5) * 0.8;
	const hill2 = Math.sin(i * 0.3) * Math.cos(j * 0.4) * 0.6;
	return (hill1 + hill2) * height * 0.5;
Valleys: 
	const valley1 = Math.sin(i * 0.4) * Math.cos(j * 0.4) * 1.2;
	const valley2 = Math.sin(i * 0.7) * Math.cos(j * 0.6) * 0.8;
	return (valley1 + valley2) * height * 0.8;
Rough:
	const noise1 = Math.sin(i * 0.8) * Math.cos(j * 0.8) * 0.4;
	const noise2 = Math.sin(i * 1.3) * Math.cos(j * 0.9) * 0.3;
	const noise3 = Math.sin(i * 2.1) * Math.cos(j * 1.8) * 0.15;
	const deterministicNoise = (pseudoRandom(i, j) - 0.5) * 0.3;
	return (noise1 + noise2 + noise3 + deterministicNoise) * height * 0.6;
What it tells:
	Surfaces are defined by vertices in 3D (x, y, z).
	By using surface’s grid, 
	Normals → perpendicular vectors to each face (from cross products).
	Centroids → average of triangle vertices.
 
What it shows:
Velocity (red): (1.14, 0.00, 0.00)
	Ball is moving to right.
	No vertical (y) or forward/backward (z) motion.
Normal (green): (-0.08, 0.99, -0.11)
	Ball is almost on flat ground but tilted slightly toward negative x and negative z.
Projection (blue): (0.01, -0.09, 0.01)
	Negative y (−0.09) → that piece is directed downward into the ground.
Reflection (yellow): (1.13, 0.18, -0.02)
	x → rightward motion.
	y → upward push from the slope.
	z → backward motion 
3.3.  How the Results Related to the Original Problem

    The project successfully addressed the original problem statement:
• Precise Mathematics: The accurate visualization of vectors and the correct bounce behavior demonstrate the successful application of dot products, cross products, and vector reflection formulas.
• High-Performance Rendering: The simulation runs smoothly in a web browser, achieving a high frame rate, which confirms the efficiency of the chosen technologies (React Three Fiber) and the implemented algorithms.
• User Interactivity: The provided UI controls (terrain type selection, reset) and immediate visual/numerical feedback create an intuitive and educational user experience, fulfilling the goal of interactivity.
 
4. Application Configuration

4.1. Hardware Requirements

• Processor: Modern Multi-core CPU (Intel i5 or AMD Ryzen 5 or better recommended).
• RAM: 8 GB minimum (16 GB preferred for optimal performance).
• GPU: Any modern graphics card with WebGL support (Discrete NVIDIA or AMD GPU recommended for best experience).
• Storage: SSD with at least 100 MB of free space.
• Input: Mouse and Keyboard for interaction.

4.2. Software Requirements

• Operating System: Windows 10+, macOS Catalina+, or a modern Linux distribution (Ubuntu 20.04+).
• Web Browser: Latest version of Chrome, Firefox, Safari, or Edge.
• Development Stack: Node.js (v16+), npm or yarn.
• Key Libraries & Frameworks: React, TypeScript, React Three Fiber, Three.js, Drei, Tailwind CSS.
• IDE: Visual Studio Code, WebStorm, or any modern code editor.












5. Conclusion

5.1. Summary

    Our project demonstrates the effective application of linear algebra concepts to create a realistic 3D collision detection and response simulation. By leveraging vector operations in R³, we successfully implemented a system that accurately detects collisions, calculates surface normals, and determines physically plausible reflection vectors. The project achieves its goals of accuracy, performance, and usability, providing a powerful visual tool for understanding abstract mathematical and physical principles. The use of modern web technologies like React Three Fiber makes this complex simulation accessible and interactive directly in a web browser.

5.2. Future Work

• Advanced Physics: Incorporate friction, rotation (torque), air resistance, and inelastic collisions.
• Complex Shapes: Extend collision detection beyond spheres to arbitrary 3D meshes.
• Procedural Generation: Create infinite or more complex terrains using advanced algorithms.
• Multi-Body Simulation: Implement collisions between multiple dynamic objects.
• Data Graphing: Add real-time graphs to plot physical quantities like velocity, energy, and force over time.

5.3. Real-life Application

Games: Popular computer games, which involve objects rolling, falling, and colliding. 
Filming: Core physics behind realistic gameplay & VFX engines.
Sports & Product Design: Digital twin testing of balls, shoes, tires.
Civil Engineering & Geophysics: Predicting rockfall/landslide paths to protect lives.



6. References
1) https://academyofanimatedart.com/3d-modeling-for-games/
2) https://scispace.com/pdf/a-process-algebra-for-games-1hxp8xfci9.pdf
3) https://www.wolfire.com/blog/2009/07/linear-algebra-for-game-developers-part-1/



**************************************

